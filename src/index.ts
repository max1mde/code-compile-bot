import {Client, ActivityType, Events, TextInputStyle, GatewayIntentBits, SlashCommandBuilder} from 'discord.js';
import token from '../token.json';
import config from './config.json';
import { spawn } from 'child_process';
const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMembers, GatewayIntentBits.MessageContent, GatewayIntentBits.GuildMessages, GatewayIntentBits.DirectMessages] });

const tutorialCommand = require('./commands/tutorial');

client.once(Events.ClientReady, () => {
	console.log(`Bot is ready! ${client.user.username}`);

	client.user.setPresence({
		activities: [{ name: `errors generated by the bad code of my users`, type: ActivityType.Watching }],
		status: 'online',
	});
	client.guilds.cache.forEach(guild => {
		registerCommands(guild);
	});
	const size = client.guilds.cache.size;
	console.log("Registered commands on " + size + (size > 1 ? " guilds!" : " guild!"));
});

client.on(Events.InteractionCreate, async (interaction) => {
	if (!interaction.isCommand()) return;
	const { commandName } = interaction;
	if (commandName === 'tutorial') {
		await tutorialCommand.execute(interaction);
	}
});

client.on(Events.MessageCreate, async (message) => {
	if (!message.content.trim() || message.author.bot || message.author === client.user) return;
	if (message.content.startsWith('!') || message.content.startsWith('run') && message.content.includes('```')) {
		if(!config.allowedUsers.includes(Number(message.author.id))) {
			await message.reply("No permission!");
			return;
		}
		await compileCode(message);
	}
});

async function compileCode(message) {
	const codeBlock = message.content.match(/```(?:([a-zA-Z]+)\s+)?([\s\S]+?)\s*```/);
	if (!codeBlock) {
		await message.reply('Invalid code block format.');
		return;
	}
	const codeString = codeBlock[2].trim();
	let output = '';
	let javaCodeWithoutMain = `
import java.io.*;
import java.util.*;
import java.awt.*;
public class Main {
	${codeString}
}`;

	let javaCodeWithMain = `
import java.io.*;
import java.util.*;
import java.awt.*;
public class Main {
	public static void main(String[] args) {
		${codeString}
	}
}`;

	const javaFileName = "Main.java";

	// Save the Java code to a file
	const fs = require('fs');
	fs.writeFileSync(javaFileName, codeString.includes("public static void main(String[] args)") ? javaCodeWithoutMain : javaCodeWithMain, {encoding: 'utf-8'});

	// Compile the Java code
	const javacProcess = spawn('javac', [javaFileName]);

	javacProcess.stderr.on('data', (data) => {
		output += `${data}`;
	});

	javacProcess.on('close', (code) => {
		if (code === 0) {
			excecuteCode(output, message, codeString);
		} else {
			message.reply("## Error!\nError during Java code execution:\n" + output);
		}
	});
}

function excecuteCode(output, message, code) {
	//const javaProcess = spawn('java', ['-classpath', '.', 'Main']);
	const javaProcess = spawn('java', ['-classpath', '.', '-Djava.security.manager', '-Djava.security.policy=java.policy', 'Main']);

	javaProcess.stdout.on('data', (data) => {
		output += data.toString();
	});

	javaProcess.stderr.on('data', (data) => {
		output += `${data}`;
	});

	javaProcess.on('close', () => {
		// Send the output back to the Discord channel
		if (output && output.trim().length > 0) {
			const finalMessage = "# Output\n```" +
				output
				+ "```"

			if (finalMessage.length > 2000) {
				message.reply("## Error!\nThe output is to long!");
			} else {
				if(isValid(output, code)) {
					message.reply(finalMessage);
				} else {
					message.reply("The output was blocked by a filter!");
				}
			}
		} else {
			message.reply('No output!');
		}
	});
}

client.on(Events.GuildCreate, guild => {
	console.log(`Joined new guild: ${guild.name} (${guild.id})`);
	registerCommands(guild);
});

function isValid(output, code) {
	const text = output.toString();
	return !(text.includes(token.token.toString()) || code.includes("os.name") || code.includes("new File") || code.includes("Scanner") || code.includes("token.json") || code.includes("Runtime.getRuntime()") || code.includes("InetAddress") || code.includes("System.getProperty"));
}

async function registerCommands(guild) {
	try {
		await guild.commands.create(tutorialCommand.data.toJSON());
	} catch (error) {
		console.error(`Error registering commands in guild: ${guild.name} (${guild.id}) - ${error}`);
	}
}

client.login(token.token);